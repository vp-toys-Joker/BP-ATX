;
; OnOffCtrl.asm
; version 0.2  
; оптимизировано по рамеру flash: 
; на 12,5% меньше код занимает памяти по сравнению с v 0.1
; Created: 16.11.2019 13:37:24
; Author : vp
;
;====================================================================
;====================================================================
;                       DEFINITIONS
;====================================================================
;.set _DEBUG_ = 1
.def fdel = r0  ;1 - флаг четного прерывания или делителя частоты: 0 - четный (пропуск счета); 1 - нечетный (счет)
;==============================================================================================
;                               Состояния и режимы
;==============================================================================================
;====================================================================
; state |                       0 - отключен                        |
;====================================================================
; mode  | Готовность | Ожидание включения | Индикация неисправности |
;       |  Ожидание  | (появление напряже-| (БП не запустился или   |
;       |  кнопки    |  ния)              | самопроизвольно отключ. |
;       |============================================================
;       |     0      |         1          |          2              |
;====================================================================
; state |                       1 - включен                         |
;====================================================================
; mode  | Готовность | Ожидание отключения| Индикация неисправности |
;       | Ожидание   |(пропадание напряже-| (БП не отключился)      |
;       | кнопки     | ния)               |                         |
;       |============================================================
;       |    0       |         1          |          2              |
;====================================================================
.def state = r1      ; состояние: 0 - отключен; 1 - включен
.def mode = r2       ; режим состояния
.def button = r3    ; событие нажатия кнопки: 0 - нет события; 1 - была нажата и отжата.
.def key_state = r4 ; состояние обработчика нажатия кнопки: 
                     ;     0 - ожидание: начальное значение - устанавл. обработчик key_process
                     ;     1 - событие обработчика прерывания - произошло изменение входа INT0 - начало обработки дребезга контактов
                     ;     2 - событие обработчика прерывания - обработка дребезга контактов и определение состояния кнопки
                     ;         устанавл. обработчик key_process
.def pwr_ok_event = r5; событие изменения состояния контрольного сигнала PW_OK
                     ;     0 - ожидание: нет события;
                     ;     1 - событие - состояние изменилось
.def pwr_ok_state = r6; состояние входа контрольного сигнала PW_OK
                     ;     0 - нет напряжения;
                     ;     1 - есть напряжение
.def const_0 = r7    ; регистр должен быть равен 0
.def const_1 = r8    ; регистр должен быть равен 1
.def const_2 = r9    ; регистр должен быть равен 2

.def temp1 = r16
.def temp2 = r17
.def temp3 = r18

.INCLUDE "macros.inc"
.INCLUDE "constants_time.inc"
.INCLUDE "var-offonctrl.inc"

.CSEG              
.ORG 0
;===========================================================================================
;                           Сброс и векторы прерываний
;===========================================================================================
	rjmp start
	rjmp _int0
	rjmp pcint
	rjmp tim_ovo
	rjmp ee_rdy
	rjmp ana_comp
	rjmp tim_compa
	rjmp tim_compb
	rjmp watch_dog
	rjmp ADConv


.INCLUDE "calls.asm"

;===========================================================================================
;                            Инициализация программы
;===========================================================================================
start:
	ldi temp1, low(RAMEND)
	out SPL, temp1
    ;=====================================================
	;           настройка портов ввода/вывода
    ;=====================================================
	ldi temp1, 0x19   ; b00011001
    out ddrB, temp1	; B1,B2,B5 - входы, B0,B3,B4 - выходы
	ldi temp1, 0x1A	; b00011010 B1 с подтяжкой,B2,B5-без;B0=0,B3,B4==1
	out portB, temp1
    ;=====================================================
	;     настройка предделителя тактового генератора
    ;=====================================================
.ifdef _DEBUG_
	in  temp1, clkpr	; контроль регистра до операции
.endif
	ldi temp1, 0x80
	ldi temp2, 0x01   ; Кдел предделителя тактового генератора = 2
	out clkpr, temp1
	out clkpr, temp2
.ifdef _DEBUG_
	in  temp1, clkpr  ; контроль регистра после операции
.endif
    ;=====================================================
    ;               настройка таймера
    ;=====================================================
	clr temp1
	out timsk0, temp1	; прерывания от таймера T0 запрещены
	out tccr0a, temp1	; режим T0 - normal, OCR0A и OCR0B отключены от выводов 
	ldi temp1, 0xff	;
	out ocr0a, temp1
	ldi temp1, 0x02   ; Кдел предделителя T0 = 8
	out tccr0b, temp1	
    ;=====================================================
    ;               инициализация памяти
    ;=====================================================
    clr fdel    ; сброс программного делителя частоты прерывания TCNT0
    clr state   ; установка нулевого состояния - БП отключен
    clr mode    ; установка режима ожидания нажатия кнопки для включения БП
    clr button  ; сброс события нажатия кнопки
    clr key_state  ; сброс состояния обработчика нажатия кнопки
    ;clr pwr_ok_state  ; сброс состояния входа контроля напряжения
    in pwr_ok_state, pinB  ; установка состояния входа контроля напряжения
    ldi temp1, 0x04
    and pwr_ok_state, temp1
    lsr pwr_ok_state
    lsr pwr_ok_state
    clr pwr_ok_event  ; сброс состояния обработчика контроля напряжения
    clr const_1;
    ldi temp3, 1
    mov const_1, temp3
    ldi temp3, 2
    mov const_2, temp3
.ifdef _DEBUG_
    clr shatter_count  ; инициал. счетчика процесса дребезга контактов от кнопки (для отладки)
    clr shatter2_count ; инициал. счетчика процесса дребезга контактов от контроля напряжения (для отладки)
.endif
    ;=====================================================
    ;           инициализация таймеров: отключение
    ;=====================================================
     clr temp3
     sts timer01, temp3
     sts timer02, temp3
     sts timer03, temp3
     sts timer0Z, temp3
    ;=====================================================
    ;       задается прерывание переполнения TCNT0
    ;=====================================================
    ldi temp1, 0x02       ; 0x02 - бит прерывания от переполнения TCNT0
    in temp2, timsk0
    or temp2, temp1
    out timsk0, temp2     ; устанавливается разрешение прерывания от переполнения TCNT0
    ;=====================================================
    ;   задается номер прерывания PCINT2
    ;=====================================================
    _SET_NUM_PCIE_ temp1, temp2, 0x04   ; 0x04 - задается номер прерывания PCINT2
    ;=====================================================
    ; задается режим внешнего прерывания INT0 
    ; 0 - по низкому уровню
    ; 1 - при любом изменении 
    ; 2 - по спаду
    ; 3 - по фронту
    ;=====================================================
    _MODE_INT0_ temp1, temp2, 1   
    ;=========================================================
    ; задается разрешение от внешнего прерывания INT0 и PCIE
    ;=========================================================
    _EN_EXTINT_ temp1, temp2, 0x60  ; 0x40 - бит прерывания от INT0 + 0x20 - бит прерывания от PCIE
    ;=====================================================
    ;       Сброс флагов прерываний от таймера
    ;=====================================================
    clr temp1
    out tifr0, temp1
    sei
;===========================================================================================
;                            Основная программа
;===========================================================================================
main_loop:
    ;=====================================================
    ;              Определение состояния системы
    ;=====================================================
    cp state, const_1
    breq main_loop_state1
    rcall main_state0
    rjmp main_loop_continue

main_loop_state1:
    rcall main_state1

main_loop_continue:    
    rcall main_loop_indication
    rjmp main_loop

;===========================================================================================
;                           Определение попдпрограмм
;===========================================================================================
    ;=====================================================
    ;          ПП   Обработка состояния 0 - "Отключен"
    ;=====================================================
main_state0:
    cp mode, const_1
    breq main_loop_state0_mode1
    rcall main_state0_mode0
    rjmp main_state0_return

main_loop_state0_mode1:
    rcall main_state0_mode1

main_state0_return:
    ret

    ;=====================================================
    ;          ПП   Обработка состояния 0 - режим 0
    ;=====================================================
main_state0_mode0:
    rcall  pwr_ctrl_process  ; вызов пп контроля сигнала PW_OK
    cp pwr_ok_state, const_1
    breq main_state0_mode0_return  ; если 1 - неисправность МК
    rcall key_process   ; вызов обработчика события от кнопки
    cp button, const_1  ; проверка события от кнопки
    brne main_state0_mode0_return  ; если 0
    ; если 1
    ;=====================================================
    ; Кнопка была нажата и отпущена. Переход в режим 1
    ;=====================================================
;main_state0_mode0_set_mode1:
    clr button ; сброс события от кнопки
    ldi temp3, 1    ; запустить таймеры сразу после инициализации
    ; запуск таймера звука - звуковое подтверждение нажатия кнопки
    ; и запуск таймера ожидания включения БП
    rcall set_sound_wait_timers
    _OCR0A_On_ temp1, temp2 ; включить звук - звуковое подтверждение нажатия кнопки
    ;Включение БП
    in temp1, PinB
    ldi temp2, 0xf7
    and temp1, temp2
    out portB, temp1  ; установить в 0 сигнал PS_ON БП
    ; установить режим 1 состояния 0
    inc mode
main_state0_mode0_return:
    ret

    ;=====================================================
    ;          ПП   Обработка состояния 0 - режим 1
    ;=====================================================
main_state0_mode1:
    rcall  pwr_ctrl_process  ; вызов пп контроля сигнала PW_OK
    ; проверка включения БП
    cp pwr_ok_state, const_1                          ; 1 - сигнал PW_OK присутствует
    brne  main_state0_mode1_off         ; 0 - отсутствует
main_state0_mode1_on:
    ; БП включился
    ; установка режима 0 состояния 1
    clr mode   ; установить режим 0 состояния 1
    inc state  ; установить состояние 1
    ; управление светодиодом индикации включения/отключения БП
    ldi temp1, 0xef
    in temp2, pinB
    and temp2, temp1
    out portB, temp2  ; включить светодиод
    ldi temp3, 0
    sts timer02, temp3 ; отключить таймер мигания светодиода 
    sts timer03, temp3 ; отключить таймер ожидания включения
    rjmp main_state0_mode1_return
main_state0_mode1_off:
    ; ожидание включения БП
    lds temp1, timer03
    cpi temp1, 0
    brne main_state0_mode1_return
    ; БП не включился - сбой включения
    clr mode   ; установить режим 0 состояния 0
    in temp1, PinB
    ldi temp2, 0x08
    or temp1, temp2
    out portB, temp1  ; установить в 0 сигнал PS_ON БП
    rcall set_power_error
main_state0_mode1_return:
    ret

;==============================================================================

    ;=====================================================
    ;          ПП   Обработка состояния 1 - "Включен"
    ;=====================================================
main_state1:
    cp mode, const_1
    breq main_loop_state1_mode1
    rcall main_state1_mode0
    rjmp main_state1_return

main_loop_state1_mode1:
    rcall main_state1_mode1

main_state1_return:
    ret

    ;=====================================================
    ;          ПП   Обработка состояния 1 - режим 0
    ;=====================================================
main_state1_mode0:
    rcall  pwr_ctrl_process  ; вызов пп контроля сигнала PW_OK
    ; проверка работы БП
    cp pwr_ok_state, const_1                          ; 1 - сигнал PW_OK присутствует
    brne  main_state1_mode0_off         ; 0 - отсутствует
    rcall key_process   ; вызов обработчика события от кнопки
    cp button, const_1  ; проверка наличия события от кнопки
    brne main_state1_mode0_return  ; если 0
    ; если 1
    ;=====================================================
    ; Кнопка была нажата и отпущена. Переход в режим 1
    ;=====================================================
    clr button ; сброс события кнопки
    ldi temp3, 1    ; запустить таймеры сразу после инициализации
    ; запуск таймера звука - звуковое подтверждение нажатия кнопки
    ; и запуск таймера ожидания отключения БП
    rcall set_sound_wait_timers
    _OCR0A_On_ temp1, temp2 ; включить звук - звуковое подтверждение нажатия кнопки
    ;Отключение БП
main_state1_mode0_set_mode1:
    in temp1, PinB
    ldi temp2, 0x08
    or temp1, temp2
    out portB, temp1  ; установить в 0 сигнал PS_ON БП
    ; установить режим 1 состояния 1
    inc mode
    rjmp main_state1_mode0_return
main_state1_mode0_off:
    ; БП самопроизвольно отключился
    rcall set_power_error
    rjmp main_state1_mode0_set_mode1
main_state1_mode0_return:
    ret

    ;=====================================================
    ;          ПП   Обработка состояния 1 - режим 1
    ;=====================================================
main_state1_mode1:
    rcall  pwr_ctrl_process  ; вызов пп контроля сигнала PW_OK
    ; проверка отключения БП
    cp pwr_ok_state, const_0                          ; 0 - сигнал PW_OK отсутствует
    brne  main_state1_mode1_on          ; 1 - присутствует
main_state1_mode1_off:
    ; БП отключился
    ; установка режима 0 состояния 0
    clr mode   ; установить режим 0 состояния 0
    clr state  ; установить состояние 0
    ; управление светодиодом индикации включения/отключения БП
    ldi temp1, 0xef
    in temp2, pinB
    and temp2, temp1
    out portB, temp2  ; отключить светодиод
    rjmp main_state1_mode1_return
main_state1_mode1_on:
    ; ожидание отключения БП
    lds temp1, timer03
    cpi temp1, 0
    brne main_state1_mode1_return
    ; БП не отключился - сбой отключения
    rcall set_power_error
    rjmp main_state1_mode1_off
main_state1_mode1_return:
    ret

;==============================================================================

    ;=====================================================
    ;                ПП  Модель индикации
    ;=====================================================
main_loop_indication:
    lds temp1, timer01
    tst temp1
    brne main_loop_indication_continue
	_OCR0A_Off_ temp1, temp2    ; отключить звук
main_loop_indication_continue:
    cp state, const_0
    brne main_loop_indication_return
    ; индикация нулевого состояния сетодиодом
    lds temp1, timer02
    tst temp1
    brne main_loop_indication_return
    ; управление светодиодом индикации включения/отключения БП
    ldi XL, LOW(timer02)
    ldi temp1, LOW(led_light_time)
    ldi temp2, HIGH(led_light_time)
    ldi temp3, 1
    rcall _set_timer_proc_
    ldi temp1, 0x10
    in temp2, pinB
    eor temp2, temp1
    out portB, temp2
    ; индикация неисправности: случай неотключения БП
    cp pwr_ok_state, const_1
    brne main_loop_indication_return
    and temp2, temp1
    cpi temp2, 0x10
    brne main_loop_indication_return
    ldi XL, LOW(timer01)
    ldi temp1, LOW(led_light_time)
    ldi temp2, HIGH(led_light_time)
    ldi temp3, 1
    rcall _set_timer_proc_
	_OCR0A_On_ temp1, temp2    ; включить звук
  
main_loop_indication_return:
    ret

;===========================================================================================
;                            Обработчики прерываний
;===========================================================================================
tim_ovo: 
;=========================================================
;     Прерывание от переполнения таймера T0
;   прерывание реализует логику программных таймеров
;=========================================================
    ; Сохранение регистров в стеке
    push temp1
    in temp1, sreg
    push temp1
    push YL
    push YH
    push XL
    push r24
    push r25
    ;=====================================================
    ;               делитель частоты на 2
    ;=====================================================
    ldi YL, low(timer01)   ; указать адрес на первый таймер
    clr YH
    tst fdel      ; проверка четности цикла
    breq tim_ovo_return   ; если 0 - пропуск счета, цикл четный
    ;=====================================================
    ;           Цикл проверки и работы всех таймеров
    ;=====================================================
    ldi XL, LOW( timer0Z)   ; загрузить мл. байт адреса структуры timer0Z - последняя запись таймеров
    inc XL  ; +1 для того чтобы сделать XL заведомо больше адреса timer0Z и операцию brlt не дополнять операцией breq
tim_ovo_repeat:
    ld r24, Y   ; загрузить состояние текущего таймера
    tst r24
    breq tim_ovo_next ; если 0 - текущий таймер не включен
    ldd r24, Y+1    ; загрузка значение текущего таймера - мл. байт
    ldd r25, Y+2    ; загрузка значение текущего таймера - ст. байт
    sbiw r24, 1     ; уменьшение значения текущего таймера
    std Y+1, r24    ; сохранение значения текущего таймера - мл. байт
    std Y+2, r25    ; сохранение значения текущего таймера - ст. байт
    or r24, r25     ; проверка на 0
    brne tim_ovo_next
    st Y, r24       ; сбросить состояние текущего таймера в 0 (не активный)
tim_ovo_next:
    adiw Y, 3   ; установить адрес на следующую структуру таймера
    cp YL, XL   ; проверить на конец таблицы таймеров. здесь XL > адреса timer0Z на 1 (timer0Z - последняя структура таймеров) 
    brlt tim_ovo_repeat   ; если это не конец, то перейти к следующей записи.
    ;breq tim_ovo_repeat
    ;=====================================================
    ;           Завешение обработки прерывания
    ;=====================================================
tim_ovo_return:
    ldi r25, 1
    eor fdel, r25
    ; восстановление регистров из стека
    pop r25
    pop r24
    pop XL
    pop YH
    pop YL
    pop temp1
    out sreg, temp1
    pop temp1
    
	reti


_int0: 
;=========================================================
;  Прерывание по INT0 - обработка события от кнопки
;        Включение или отключение устройства
;=========================================================
    ; Сохранение регистров в стеке
    push temp1
    in temp1, sreg
    push temp1
    push temp2

    ;=========================================================
    ;     key_state - состояние обработчика нажатия кнопки
    ;     0 - ожидание - начальное значение - уст. обработчик key_process;
    ;     1 - произошло изменение состояния входа INT0 - уст. здесь
    ;     2 - обработка дребезга котактов - уст. обработчик key_process;
    ;=========================================================
    inc key_state
    ;=========================================================
    ;       задается запрет от внешнего прерывания INT0
    ;=========================================================
;_int0_disable_:
    _DIS_EXTINT_ temp1, temp2, 0x40  ; 0x40 - бит прерывания от INT0
    ; восстановление регистров из стека
    pop temp2
    pop temp1
    out sreg, temp1
    pop temp1
    
	reti

pcint: 
;=========================================================
;         Прерывание по PCIE2 - обработка любого 
;             изменения состояния входа B2
;       Слежение за контрольным сигналом устройства
;=========================================================
    ; Сохранение регистров в стеке
    push temp1
    in temp1, sreg
    push temp1
    push temp2
   
    ; Пока считаю, что от напряжения питания дребезга нет, т.к. на нем емкостная нагрузка
    inc pwr_ok_event
    ;=========================================================
    ;       задается запрет от внешнего прерывания PCIE2
    ;=========================================================
;_pcint_disable_:
    _DIS_EXTINT_ temp1, temp2, 0x20  ; 0x20 - бит прерывания от PCIE

    ; восстановление регистров из стека
    pop temp2
    pop temp1
    out sreg, temp1
    pop temp1
    
	reti

ee_rdy: 
ana_comp:
tim_compa: 
tim_compb: 
watch_dog: 
ADConv: 
reti